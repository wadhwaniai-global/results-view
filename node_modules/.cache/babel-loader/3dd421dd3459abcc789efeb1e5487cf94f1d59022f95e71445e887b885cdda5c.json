{"ast":null,"code":"// src/errors/IcebergError.ts\nvar IcebergError = class extends Error {\n  constructor(message, opts) {\n    super(message);\n    this.name = \"IcebergError\";\n    this.status = opts.status;\n    this.icebergType = opts.icebergType;\n    this.icebergCode = opts.icebergCode;\n    this.details = opts.details;\n    this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\n  }\n  /**\n   * Returns true if the error is a 404 Not Found error.\n   */\n  isNotFound() {\n    return this.status === 404;\n  }\n  /**\n   * Returns true if the error is a 409 Conflict error.\n   */\n  isConflict() {\n    return this.status === 409;\n  }\n  /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */\n  isAuthenticationTimeout() {\n    return this.status === 419;\n  }\n};\n\n// src/utils/url.ts\nfunction buildUrl(baseUrl, path, query) {\n  const url = new URL(path, baseUrl);\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (value !== void 0) {\n        url.searchParams.set(key, value);\n      }\n    }\n  }\n  return url.toString();\n}\n\n// src/http/createFetchClient.ts\nasync function buildAuthHeaders(auth) {\n  if (!auth || auth.type === \"none\") {\n    return {};\n  }\n  if (auth.type === \"bearer\") {\n    return {\n      Authorization: `Bearer ${auth.token}`\n    };\n  }\n  if (auth.type === \"header\") {\n    return {\n      [auth.name]: auth.value\n    };\n  }\n  if (auth.type === \"custom\") {\n    return await auth.getHeaders();\n  }\n  return {};\n}\nfunction createFetchClient(options) {\n  const fetchFn = options.fetchImpl ?? globalThis.fetch;\n  return {\n    async request({\n      method,\n      path,\n      query,\n      body,\n      headers\n    }) {\n      const url = buildUrl(options.baseUrl, path, query);\n      const authHeaders = await buildAuthHeaders(options.auth);\n      const res = await fetchFn(url, {\n        method,\n        headers: {\n          ...(body ? {\n            \"Content-Type\": \"application/json\"\n          } : {}),\n          ...authHeaders,\n          ...headers\n        },\n        body: body ? JSON.stringify(body) : void 0\n      });\n      const text = await res.text();\n      const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\n      const data = isJson && text ? JSON.parse(text) : text;\n      if (!res.ok) {\n        const errBody = isJson ? data : void 0;\n        const errorDetail = errBody?.error;\n        throw new IcebergError(errorDetail?.message ?? `Request failed with status ${res.status}`, {\n          status: res.status,\n          icebergType: errorDetail?.type,\n          icebergCode: errorDetail?.code,\n          details: errBody\n        });\n      }\n      return {\n        status: res.status,\n        headers: res.headers,\n        data\n      };\n    }\n  };\n}\n\n// src/catalog/namespaces.ts\nfunction namespaceToPath(namespace) {\n  return namespace.join(\"\u001f\");\n}\nvar NamespaceOperations = class {\n  constructor(client, prefix = \"\") {\n    this.client = client;\n    this.prefix = prefix;\n  }\n  async listNamespaces(parent) {\n    const query = parent ? {\n      parent: namespaceToPath(parent.namespace)\n    } : void 0;\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces`,\n      query\n    });\n    return response.data.namespaces.map(ns => ({\n      namespace: ns\n    }));\n  }\n  async createNamespace(id, metadata) {\n    const request = {\n      namespace: id.namespace,\n      properties: metadata?.properties\n    };\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces`,\n      body: request\n    });\n    return response.data;\n  }\n  async dropNamespace(id) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n    });\n  }\n  async loadNamespaceMetadata(id) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n    });\n    return {\n      properties: response.data.properties\n    };\n  }\n  async namespaceExists(id) {\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createNamespaceIfNotExists(id, metadata) {\n    try {\n      return await this.createNamespace(id, metadata);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return;\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/tables.ts\nfunction namespaceToPath2(namespace) {\n  return namespace.join(\"\u001f\");\n}\nvar TableOperations = class {\n  constructor(client, prefix = \"\", accessDelegation) {\n    this.client = client;\n    this.prefix = prefix;\n    this.accessDelegation = accessDelegation;\n  }\n  async listTables(namespace) {\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\n    });\n    return response.data.identifiers;\n  }\n  async createTable(namespace, request) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\n      body: request,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async updateTable(id, request) {\n    const response = await this.client.request({\n      method: \"POST\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      body: request\n    });\n    return {\n      \"metadata-location\": response.data[\"metadata-location\"],\n      metadata: response.data.metadata\n    };\n  }\n  async dropTable(id, options) {\n    await this.client.request({\n      method: \"DELETE\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      query: {\n        purgeRequested: String(options?.purge ?? false)\n      }\n    });\n  }\n  async loadTable(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    const response = await this.client.request({\n      method: \"GET\",\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n      headers\n    });\n    return response.data.metadata;\n  }\n  async tableExists(id) {\n    const headers = {};\n    if (this.accessDelegation) {\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\n    }\n    try {\n      await this.client.request({\n        method: \"HEAD\",\n        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\n        headers\n      });\n      return true;\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false;\n      }\n      throw error;\n    }\n  }\n  async createTableIfNotExists(namespace, request) {\n    try {\n      return await this.createTable(namespace, request);\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return await this.loadTable({\n          namespace: namespace.namespace,\n          name: request.name\n        });\n      }\n      throw error;\n    }\n  }\n};\n\n// src/catalog/IcebergRestCatalog.ts\nvar IcebergRestCatalog = class {\n  /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */\n  constructor(options) {\n    let prefix = \"v1\";\n    if (options.catalogName) {\n      prefix += `/${options.catalogName}`;\n    }\n    const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\n    this.client = createFetchClient({\n      baseUrl,\n      auth: options.auth,\n      fetchImpl: options.fetch\n    });\n    this.accessDelegation = options.accessDelegation?.join(\",\");\n    this.namespaceOps = new NamespaceOperations(this.client, prefix);\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\n  }\n  /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */\n  async listNamespaces(parent) {\n    return this.namespaceOps.listNamespaces(parent);\n  }\n  /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */\n  async createNamespace(id, metadata) {\n    return this.namespaceOps.createNamespace(id, metadata);\n  }\n  /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */\n  async dropNamespace(id) {\n    await this.namespaceOps.dropNamespace(id);\n  }\n  /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */\n  async loadNamespaceMetadata(id) {\n    return this.namespaceOps.loadNamespaceMetadata(id);\n  }\n  /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */\n  async listTables(namespace) {\n    return this.tableOps.listTables(namespace);\n  }\n  /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTable(namespace, request) {\n    return this.tableOps.createTable(namespace, request);\n  }\n  /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */\n  async updateTable(id, request) {\n    return this.tableOps.updateTable(id, request);\n  }\n  /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */\n  async dropTable(id, options) {\n    await this.tableOps.dropTable(id, options);\n  }\n  /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */\n  async loadTable(id) {\n    return this.tableOps.loadTable(id);\n  }\n  /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async namespaceExists(id) {\n    return this.namespaceOps.namespaceExists(id);\n  }\n  /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async tableExists(id) {\n    return this.tableOps.tableExists(id);\n  }\n  /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */\n  async createNamespaceIfNotExists(id, metadata) {\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\n  }\n  /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTableIfNotExists(namespace, request) {\n    return this.tableOps.createTableIfNotExists(namespace, request);\n  }\n};\n\n// src/catalog/types.ts\nfunction getCurrentSchema(metadata) {\n  return metadata.schemas.find(s => s[\"schema-id\"] === metadata[\"current-schema-id\"]);\n}\nexport { IcebergError, IcebergRestCatalog, getCurrentSchema };\n\n//# sourceMappingURL=index.mjs.map","map":{"version":3,"names":["IcebergError","Error","constructor","message","opts","name","status","icebergType","icebergCode","details","isCommitStateUnknown","includes","isNotFound","isConflict","isAuthenticationTimeout","buildUrl","baseUrl","path","query","url","URL","key","value","Object","entries","searchParams","set","toString","buildAuthHeaders","auth","type","Authorization","token","getHeaders","createFetchClient","options","fetchFn","fetchImpl","globalThis","fetch","request","method","body","headers","authHeaders","res","JSON","stringify","text","isJson","get","data","parse","ok","errBody","errorDetail","error","code","namespaceToPath","namespace","join","NamespaceOperations","client","prefix","listNamespaces","parent","response","namespaces","map","ns","createNamespace","id","metadata","properties","dropNamespace","loadNamespaceMetadata","namespaceExists","createNamespaceIfNotExists","namespaceToPath2","TableOperations","accessDelegation","listTables","identifiers","createTable","updateTable","dropTable","purgeRequested","String","purge","loadTable","tableExists","createTableIfNotExists","IcebergRestCatalog","catalogName","endsWith","namespaceOps","tableOps","getCurrentSchema","schemas","find","s"],"sources":["/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/errors/IcebergError.ts","/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/utils/url.ts","/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/http/createFetchClient.ts","/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/catalog/namespaces.ts","/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/catalog/tables.ts","/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/catalog/IcebergRestCatalog.ts","/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/node_modules/iceberg-js/src/catalog/types.ts"],"sourcesContent":["export interface IcebergErrorResponse {\n  error: {\n    message: string\n    type: string\n    code: number\n    stack?: string[]\n  }\n}\n\nexport class IcebergError extends Error {\n  readonly status: number\n  readonly icebergType?: string\n  readonly icebergCode?: number\n  readonly details?: unknown\n  readonly isCommitStateUnknown: boolean\n\n  constructor(\n    message: string,\n    opts: {\n      status: number\n      icebergType?: string\n      icebergCode?: number\n      details?: unknown\n    }\n  ) {\n    super(message)\n    this.name = 'IcebergError'\n    this.status = opts.status\n    this.icebergType = opts.icebergType\n    this.icebergCode = opts.icebergCode\n    this.details = opts.details\n\n    // Detect CommitStateUnknownException (500, 502, 504 during table commits)\n    this.isCommitStateUnknown =\n      opts.icebergType === 'CommitStateUnknownException' ||\n      ([500, 502, 504].includes(opts.status) && opts.icebergType?.includes('CommitState') === true)\n  }\n\n  /**\n   * Returns true if the error is a 404 Not Found error.\n   */\n  isNotFound(): boolean {\n    return this.status === 404\n  }\n\n  /**\n   * Returns true if the error is a 409 Conflict error.\n   */\n  isConflict(): boolean {\n    return this.status === 409\n  }\n\n  /**\n   * Returns true if the error is a 419 Authentication Timeout error.\n   */\n  isAuthenticationTimeout(): boolean {\n    return this.status === 419\n  }\n}\n","export function buildUrl(\n  baseUrl: string,\n  path: string,\n  query?: Record<string, string | undefined>\n): string {\n  const url = new URL(path, baseUrl)\n\n  if (query) {\n    for (const [key, value] of Object.entries(query)) {\n      if (value !== undefined) {\n        url.searchParams.set(key, value)\n      }\n    }\n  }\n\n  return url.toString()\n}\n","import { IcebergError, type IcebergErrorResponse } from '../errors/IcebergError'\nimport { buildUrl } from '../utils/url'\nimport type { AuthConfig, HttpClient, HttpRequest, HttpResponse } from './types'\n\nasync function buildAuthHeaders(auth?: AuthConfig): Promise<Record<string, string>> {\n  if (!auth || auth.type === 'none') {\n    return {}\n  }\n\n  if (auth.type === 'bearer') {\n    return { Authorization: `Bearer ${auth.token}` }\n  }\n\n  if (auth.type === 'header') {\n    return { [auth.name]: auth.value }\n  }\n\n  if (auth.type === 'custom') {\n    return await auth.getHeaders()\n  }\n\n  return {}\n}\n\nexport function createFetchClient(options: {\n  baseUrl: string\n  auth?: AuthConfig\n  fetchImpl?: typeof fetch\n}): HttpClient {\n  const fetchFn = options.fetchImpl ?? globalThis.fetch\n\n  return {\n    async request<T>({\n      method,\n      path,\n      query,\n      body,\n      headers,\n    }: HttpRequest): Promise<HttpResponse<T>> {\n      const url = buildUrl(options.baseUrl, path, query)\n      const authHeaders = await buildAuthHeaders(options.auth)\n\n      const res = await fetchFn(url, {\n        method,\n        headers: {\n          ...(body ? { 'Content-Type': 'application/json' } : {}),\n          ...authHeaders,\n          ...headers,\n        },\n        body: body ? JSON.stringify(body) : undefined,\n      })\n\n      const text = await res.text()\n      const isJson = (res.headers.get('content-type') || '').includes('application/json')\n      const data = isJson && text ? (JSON.parse(text) as T) : (text as T)\n\n      if (!res.ok) {\n        const errBody = isJson ? (data as IcebergErrorResponse) : undefined\n        const errorDetail = errBody?.error\n        throw new IcebergError(\n          errorDetail?.message ?? `Request failed with status ${res.status}`,\n          {\n            status: res.status,\n            icebergType: errorDetail?.type,\n            icebergCode: errorDetail?.code,\n            details: errBody,\n          }\n        )\n      }\n\n      return { status: res.status, headers: res.headers, data: data as T }\n    },\n  }\n}\n","import type { HttpClient } from '../http/types'\nimport { IcebergError } from '../errors/IcebergError'\nimport type {\n  CreateNamespaceRequest,\n  CreateNamespaceResponse,\n  GetNamespaceResponse,\n  ListNamespacesResponse,\n  NamespaceIdentifier,\n  NamespaceMetadata,\n} from './types'\n\nfunction namespaceToPath(namespace: string[]): string {\n  return namespace.join('\\x1F')\n}\n\nexport class NamespaceOperations {\n  constructor(\n    private readonly client: HttpClient,\n    private readonly prefix: string = ''\n  ) {}\n\n  async listNamespaces(parent?: NamespaceIdentifier): Promise<NamespaceIdentifier[]> {\n    const query = parent ? { parent: namespaceToPath(parent.namespace) } : undefined\n\n    const response = await this.client.request<ListNamespacesResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces`,\n      query,\n    })\n\n    return response.data.namespaces.map((ns) => ({ namespace: ns }))\n  }\n\n  async createNamespace(\n    id: NamespaceIdentifier,\n    metadata?: NamespaceMetadata\n  ): Promise<CreateNamespaceResponse> {\n    const request: CreateNamespaceRequest = {\n      namespace: id.namespace,\n      properties: metadata?.properties,\n    }\n\n    const response = await this.client.request<CreateNamespaceResponse>({\n      method: 'POST',\n      path: `${this.prefix}/namespaces`,\n      body: request,\n    })\n\n    return response.data\n  }\n\n  async dropNamespace(id: NamespaceIdentifier): Promise<void> {\n    await this.client.request<void>({\n      method: 'DELETE',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`,\n    })\n  }\n\n  async loadNamespaceMetadata(id: NamespaceIdentifier): Promise<NamespaceMetadata> {\n    const response = await this.client.request<GetNamespaceResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`,\n    })\n\n    return {\n      properties: response.data.properties,\n    }\n  }\n\n  async namespaceExists(id: NamespaceIdentifier): Promise<boolean> {\n    try {\n      await this.client.request<void>({\n        method: 'HEAD',\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`,\n      })\n      return true\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false\n      }\n      throw error\n    }\n  }\n\n  async createNamespaceIfNotExists(\n    id: NamespaceIdentifier,\n    metadata?: NamespaceMetadata\n  ): Promise<CreateNamespaceResponse | void> {\n    try {\n      return await this.createNamespace(id, metadata)\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return\n      }\n      throw error\n    }\n  }\n}\n","import type { HttpClient } from '../http/types'\nimport { IcebergError } from '../errors/IcebergError'\nimport type {\n  CreateTableRequest,\n  CommitTableResponse,\n  ListTablesResponse,\n  LoadTableResponse,\n  NamespaceIdentifier,\n  TableIdentifier,\n  TableMetadata,\n  UpdateTableRequest,\n  DropTableRequest,\n} from './types'\n\nfunction namespaceToPath(namespace: string[]): string {\n  return namespace.join('\\x1F')\n}\n\nexport class TableOperations {\n  constructor(\n    private readonly client: HttpClient,\n    private readonly prefix: string = '',\n    private readonly accessDelegation?: string\n  ) {}\n\n  async listTables(namespace: NamespaceIdentifier): Promise<TableIdentifier[]> {\n    const response = await this.client.request<ListTablesResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces/${namespaceToPath(namespace.namespace)}/tables`,\n    })\n\n    return response.data.identifiers\n  }\n\n  async createTable(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    const headers: Record<string, string> = {}\n    if (this.accessDelegation) {\n      headers['X-Iceberg-Access-Delegation'] = this.accessDelegation\n    }\n\n    const response = await this.client.request<LoadTableResponse>({\n      method: 'POST',\n      path: `${this.prefix}/namespaces/${namespaceToPath(namespace.namespace)}/tables`,\n      body: request,\n      headers,\n    })\n\n    return response.data.metadata\n  }\n\n  async updateTable(id: TableIdentifier, request: UpdateTableRequest): Promise<CommitTableResponse> {\n    const response = await this.client.request<LoadTableResponse>({\n      method: 'POST',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n      body: request,\n    })\n\n    return {\n      'metadata-location': response.data['metadata-location'],\n      metadata: response.data.metadata,\n    }\n  }\n\n  async dropTable(id: TableIdentifier, options?: DropTableRequest): Promise<void> {\n    await this.client.request<void>({\n      method: 'DELETE',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n      query: { purgeRequested: String(options?.purge ?? false) },\n    })\n  }\n\n  async loadTable(id: TableIdentifier): Promise<TableMetadata> {\n    const headers: Record<string, string> = {}\n    if (this.accessDelegation) {\n      headers['X-Iceberg-Access-Delegation'] = this.accessDelegation\n    }\n\n    const response = await this.client.request<LoadTableResponse>({\n      method: 'GET',\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n      headers,\n    })\n\n    return response.data.metadata\n  }\n\n  async tableExists(id: TableIdentifier): Promise<boolean> {\n    const headers: Record<string, string> = {}\n    if (this.accessDelegation) {\n      headers['X-Iceberg-Access-Delegation'] = this.accessDelegation\n    }\n\n    try {\n      await this.client.request<void>({\n        method: 'HEAD',\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}/tables/${id.name}`,\n        headers,\n      })\n      return true\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 404) {\n        return false\n      }\n      throw error\n    }\n  }\n\n  async createTableIfNotExists(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    try {\n      return await this.createTable(namespace, request)\n    } catch (error) {\n      if (error instanceof IcebergError && error.status === 409) {\n        return await this.loadTable({ namespace: namespace.namespace, name: request.name })\n      }\n      throw error\n    }\n  }\n}\n","import { createFetchClient } from '../http/createFetchClient'\nimport type { AuthConfig, HttpClient } from '../http/types'\nimport { NamespaceOperations } from './namespaces'\nimport { TableOperations } from './tables'\nimport type {\n  CreateTableRequest,\n  CreateNamespaceResponse,\n  CommitTableResponse,\n  NamespaceIdentifier,\n  NamespaceMetadata,\n  TableIdentifier,\n  TableMetadata,\n  UpdateTableRequest,\n  DropTableRequest,\n} from './types'\n\n/**\n * Access delegation mechanisms supported by the Iceberg REST Catalog.\n *\n * - `vended-credentials`: Server provides temporary credentials for data access\n * - `remote-signing`: Server signs requests on behalf of the client\n */\nexport type AccessDelegation = 'vended-credentials' | 'remote-signing'\n\n/**\n * Configuration options for the Iceberg REST Catalog client.\n */\nexport interface IcebergRestCatalogOptions {\n  /** Base URL of the Iceberg REST Catalog API */\n  baseUrl: string\n  /** Optional catalog name prefix for multi-catalog servers */\n  catalogName?: string\n  /** Authentication configuration */\n  auth?: AuthConfig\n  /** Custom fetch implementation (defaults to globalThis.fetch) */\n  fetch?: typeof fetch\n  /**\n   * Access delegation mechanisms to request from the server.\n   * When specified, the X-Iceberg-Access-Delegation header will be sent\n   * with supported operations (createTable, loadTable).\n   *\n   * @example ['vended-credentials']\n   * @example ['vended-credentials', 'remote-signing']\n   */\n  accessDelegation?: AccessDelegation[]\n}\n\n/**\n * Client for interacting with an Apache Iceberg REST Catalog.\n *\n * This class provides methods for managing namespaces and tables in an Iceberg catalog.\n * It handles authentication, request formatting, and error handling automatically.\n *\n * @example\n * ```typescript\n * const catalog = new IcebergRestCatalog({\n *   baseUrl: 'https://my-catalog.example.com/iceberg/v1',\n *   auth: { type: 'bearer', token: process.env.ICEBERG_TOKEN }\n * });\n *\n * // Create a namespace\n * await catalog.createNamespace({ namespace: ['analytics'] });\n *\n * // Create a table\n * await catalog.createTable(\n *   { namespace: ['analytics'] },\n *   {\n *     name: 'events',\n *     schema: { type: 'struct', fields: [...] }\n *   }\n * );\n * ```\n */\nexport class IcebergRestCatalog {\n  private readonly client: HttpClient\n  private readonly namespaceOps: NamespaceOperations\n  private readonly tableOps: TableOperations\n  private readonly accessDelegation?: string\n\n  /**\n   * Creates a new Iceberg REST Catalog client.\n   *\n   * @param options - Configuration options for the catalog client\n   */\n  constructor(options: IcebergRestCatalogOptions) {\n    let prefix = 'v1'\n    if (options.catalogName) {\n      prefix += `/${options.catalogName}`\n    }\n\n    const baseUrl = options.baseUrl.endsWith('/') ? options.baseUrl : `${options.baseUrl}/`\n\n    this.client = createFetchClient({\n      baseUrl,\n      auth: options.auth,\n      fetchImpl: options.fetch,\n    })\n\n    // Format accessDelegation as comma-separated string per spec\n    this.accessDelegation = options.accessDelegation?.join(',')\n\n    this.namespaceOps = new NamespaceOperations(this.client, prefix)\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation)\n  }\n\n  /**\n   * Lists all namespaces in the catalog.\n   *\n   * @param parent - Optional parent namespace to list children under\n   * @returns Array of namespace identifiers\n   *\n   * @example\n   * ```typescript\n   * // List all top-level namespaces\n   * const namespaces = await catalog.listNamespaces();\n   *\n   * // List namespaces under a parent\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\n   * ```\n   */\n  async listNamespaces(parent?: NamespaceIdentifier): Promise<NamespaceIdentifier[]> {\n    return this.namespaceOps.listNamespaces(parent)\n  }\n\n  /**\n   * Creates a new namespace in the catalog.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespace(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * console.log(response.namespace); // ['analytics']\n   * console.log(response.properties); // { owner: 'data-team', ... }\n   * ```\n   */\n  async createNamespace(id: NamespaceIdentifier, metadata?: NamespaceMetadata): Promise<CreateNamespaceResponse> {\n    return this.namespaceOps.createNamespace(id, metadata)\n  }\n\n  /**\n   * Drops a namespace from the catalog.\n   *\n   * The namespace must be empty (contain no tables) before it can be dropped.\n   *\n   * @param id - Namespace identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\n   * ```\n   */\n  async dropNamespace(id: NamespaceIdentifier): Promise<void> {\n    await this.namespaceOps.dropNamespace(id)\n  }\n\n  /**\n   * Loads metadata for a namespace.\n   *\n   * @param id - Namespace identifier to load\n   * @returns Namespace metadata including properties\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\n   * console.log(metadata.properties);\n   * ```\n   */\n  async loadNamespaceMetadata(id: NamespaceIdentifier): Promise<NamespaceMetadata> {\n    return this.namespaceOps.loadNamespaceMetadata(id)\n  }\n\n  /**\n   * Lists all tables in a namespace.\n   *\n   * @param namespace - Namespace identifier to list tables from\n   * @returns Array of table identifiers\n   *\n   * @example\n   * ```typescript\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\n   * ```\n   */\n  async listTables(namespace: NamespaceIdentifier): Promise<TableIdentifier[]> {\n    return this.tableOps.listTables(namespace)\n  }\n\n  /**\n   * Creates a new table in the catalog.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTable(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     },\n   *     'partition-spec': {\n   *       'spec-id': 0,\n   *       fields: [\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\n   *       ]\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTable(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    return this.tableOps.createTable(namespace, request)\n  }\n\n  /**\n   * Updates an existing table's metadata.\n   *\n   * Can update the schema, partition spec, or properties of a table.\n   *\n   * @param id - Table identifier to update\n   * @param request - Update request with fields to modify\n   * @returns Response containing the metadata location and updated table metadata\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.updateTable(\n   *   { namespace: ['analytics'], name: 'events' },\n   *   {\n   *     properties: { 'read.split.target-size': '134217728' }\n   *   }\n   * );\n   * console.log(response['metadata-location']); // s3://...\n   * console.log(response.metadata); // TableMetadata object\n   * ```\n   */\n  async updateTable(id: TableIdentifier, request: UpdateTableRequest): Promise<CommitTableResponse> {\n    return this.tableOps.updateTable(id, request)\n  }\n\n  /**\n   * Drops a table from the catalog.\n   *\n   * @param id - Table identifier to drop\n   *\n   * @example\n   * ```typescript\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\n   * ```\n   */\n  async dropTable(id: TableIdentifier, options?: DropTableRequest): Promise<void> {\n    await this.tableOps.dropTable(id, options)\n  }\n\n  /**\n   * Loads metadata for a table.\n   *\n   * @param id - Table identifier to load\n   * @returns Table metadata including schema, partition spec, location, etc.\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\n   * console.log(metadata.schema);\n   * console.log(metadata.location);\n   * ```\n   */\n  async loadTable(id: TableIdentifier): Promise<TableMetadata> {\n    return this.tableOps.loadTable(id)\n  }\n\n  /**\n   * Checks if a namespace exists in the catalog.\n   *\n   * @param id - Namespace identifier to check\n   * @returns True if the namespace exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async namespaceExists(id: NamespaceIdentifier): Promise<boolean> {\n    return this.namespaceOps.namespaceExists(id)\n  }\n\n  /**\n   * Checks if a table exists in the catalog.\n   *\n   * @param id - Table identifier to check\n   * @returns True if the table exists, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\n   * console.log(exists); // true or false\n   * ```\n   */\n  async tableExists(id: TableIdentifier): Promise<boolean> {\n    return this.tableOps.tableExists(id)\n  }\n\n  /**\n   * Creates a namespace if it does not exist.\n   *\n   * If the namespace already exists, returns void. If created, returns the response.\n   *\n   * @param id - Namespace identifier to create\n   * @param metadata - Optional metadata properties for the namespace\n   * @returns Response containing the created namespace and its properties, or void if it already exists\n   *\n   * @example\n   * ```typescript\n   * const response = await catalog.createNamespaceIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   { properties: { owner: 'data-team' } }\n   * );\n   * if (response) {\n   *   console.log('Created:', response.namespace);\n   * } else {\n   *   console.log('Already exists');\n   * }\n   * ```\n   */\n  async createNamespaceIfNotExists(\n    id: NamespaceIdentifier,\n    metadata?: NamespaceMetadata\n  ): Promise<CreateNamespaceResponse | void> {\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata)\n  }\n\n  /**\n   * Creates a table if it does not exist.\n   *\n   * If the table already exists, returns its metadata instead.\n   *\n   * @param namespace - Namespace to create the table in\n   * @param request - Table creation request including name, schema, partition spec, etc.\n   * @returns Table metadata for the created or existing table\n   *\n   * @example\n   * ```typescript\n   * const metadata = await catalog.createTableIfNotExists(\n   *   { namespace: ['analytics'] },\n   *   {\n   *     name: 'events',\n   *     schema: {\n   *       type: 'struct',\n   *       fields: [\n   *         { id: 1, name: 'id', type: 'long', required: true },\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\n   *       ],\n   *       'schema-id': 0\n   *     }\n   *   }\n   * );\n   * ```\n   */\n  async createTableIfNotExists(\n    namespace: NamespaceIdentifier,\n    request: CreateTableRequest\n  ): Promise<TableMetadata> {\n    return this.tableOps.createTableIfNotExists(namespace, request)\n  }\n}\n","export interface NamespaceIdentifier {\n  namespace: string[]\n}\n\nexport interface NamespaceMetadata {\n  properties: Record<string, string>\n}\n\nexport interface TableIdentifier {\n  namespace: string[]\n  name: string\n}\n\nexport type IcebergType =\n  | 'boolean'\n  | 'int'\n  | 'long'\n  | 'float'\n  | 'double'\n  | 'string'\n  | 'timestamp'\n  | 'date'\n  | 'time'\n  | 'timestamptz'\n  | 'uuid'\n  | 'binary'\n  | { type: 'decimal'; precision: number; scale: number }\n  | { type: 'fixed'; length: number }\n\nexport interface TableField {\n  id: number\n  name: string\n  type: IcebergType\n  required: boolean\n  doc?: string\n}\n\nexport interface TableSchema {\n  type: 'struct'\n  fields: TableField[]\n  'schema-id'?: number\n  'identifier-field-ids'?: number[]\n}\n\nexport interface PartitionField {\n  source_id: number\n  field_id: number\n  name: string\n  transform: string\n}\n\nexport interface PartitionSpec {\n  'spec-id': number\n  fields: PartitionField[]\n}\n\nexport interface SortField {\n  source_id: number\n  transform: string\n  direction: 'asc' | 'desc'\n  null_order: 'nulls-first' | 'nulls-last'\n}\n\nexport interface SortOrder {\n  'order-id': number\n  fields: SortField[]\n}\n\nexport interface CreateTableRequest {\n  name: string\n  schema: TableSchema\n  'partition-spec'?: PartitionSpec\n  'write-order'?: SortOrder\n  properties?: Record<string, string>\n  'stage-create'?: boolean\n}\n\nexport interface UpdateTableRequest {\n  schema?: TableSchema\n  'partition-spec'?: PartitionSpec\n  properties?: Record<string, string>\n}\n\nexport interface DropTableRequest {\n  purge?: boolean\n}\n\nexport interface TableMetadata {\n  name?: string\n  location: string\n  schemas: TableSchema[]\n  'current-schema-id': number\n  'partition-specs': PartitionSpec[]\n  'default-spec-id'?: number\n  'sort-orders': SortOrder[]\n  'default-sort-order-id'?: number\n  properties: Record<string, string>\n  'metadata-location'?: string\n  'current-snapshot-id'?: number\n  snapshots?: unknown[]\n  'snapshot-log'?: unknown[]\n  'metadata-log'?: unknown[]\n  refs?: Record<string, unknown>\n  'last-updated-ms'?: number\n  'last-column-id'?: number\n  'last-sequence-number'?: number\n  'table-uuid'?: string\n  'format-version'?: number\n  'last-partition-id'?: number\n}\n\nexport interface CreateNamespaceRequest {\n  namespace: string[]\n  properties?: Record<string, string>\n}\n\nexport interface CreateNamespaceResponse {\n  namespace: string[]\n  properties?: Record<string, string>\n}\n\nexport interface GetNamespaceResponse {\n  namespace: string[]\n  properties: Record<string, string>\n}\n\nexport interface ListNamespacesResponse {\n  namespaces: string[][]\n  'next-page-token'?: string\n}\n\nexport interface ListTablesResponse {\n  identifiers: TableIdentifier[]\n  'next-page-token'?: string\n}\n\nexport interface LoadTableResponse {\n  'metadata-location': string\n  metadata: TableMetadata\n  config?: Record<string, string>\n}\n\nexport interface CommitTableResponse {\n  'metadata-location': string\n  metadata: TableMetadata\n}\n\n/**\n * Gets the current (active) schema from table metadata.\n *\n * @param metadata - Table metadata containing schemas array and current-schema-id\n * @returns The current table schema, or undefined if not found\n */\nexport function getCurrentSchema(metadata: TableMetadata): TableSchema | undefined {\n  return metadata.schemas.find((s) => s['schema-id'] === metadata['current-schema-id'])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}