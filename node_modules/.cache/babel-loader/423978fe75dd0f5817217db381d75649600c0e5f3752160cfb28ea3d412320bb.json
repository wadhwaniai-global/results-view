{"ast":null,"code":"// supabaseApi.ts - Supabase API utilities for React\nimport { supabaseClient } from '../config';\n// Student IDs and names (from data.sql)\nconst EMMA_JOHNSON_ID = '650e8400-e29b-41d4-a716-446655440001';\nconst EMMA_JOHNSON_NAME = 'Emma Johnson';\nconst LIAM_SMITH_ID = '650e8400-e29b-41d4-a716-446655440002';\nconst LIAM_SMITH_NAME = 'Liam Smith';\nconst OLIVIA_DAVIS_ID = '650e8400-e29b-41d4-a716-446655440003';\nconst OLIVIA_DAVIS_NAME = 'Olivia Davis';\n// Mapping of students to their JSON files\nconst STUDENT_JSON_MAP = {\n  [EMMA_JOHNSON_ID]: {\n    name: EMMA_JOHNSON_NAME,\n    file: 'test_input.json'\n  },\n  [LIAM_SMITH_ID]: {\n    name: LIAM_SMITH_NAME,\n    file: 'test_input3.json'\n  },\n  [OLIVIA_DAVIS_ID]: {\n    name: OLIVIA_DAVIS_NAME,\n    file: 'test_input2.json'\n  }\n};\n\n// Cache for JSON data\nconst jsonDataCache = {};\n\n// Load JSON data from specified file (always fresh, no caching)\nexport async function loadJSONData(filename) {\n  try {\n    const response = await fetch(`/${filename}?t=${Date.now()}`);\n    if (!response.ok) {\n      console.warn(`Could not load ${filename}`);\n      return null;\n    }\n    const data = await response.json();\n    jsonDataCache[filename] = data;\n    return data;\n  } catch (error) {\n    console.error(`Error loading JSON data from ${filename}:`, error);\n    return null;\n  }\n}\n\n// Get JSON file for a student\nexport function getStudentJSONFile(studentId, studentName) {\n  // Check by ID first\n  if (STUDENT_JSON_MAP[studentId]) {\n    return STUDENT_JSON_MAP[studentId].file;\n  }\n\n  // Check by name\n  for (const [id, info] of Object.entries(STUDENT_JSON_MAP)) {\n    var _info$name$split$;\n    if (studentName && (studentName === info.name || typeof studentName === 'string' && studentName.toLowerCase().includes(info.name.split(' ')[0].toLowerCase()) && studentName.toLowerCase().includes((_info$name$split$ = info.name.split(' ')[1]) === null || _info$name$split$ === void 0 ? void 0 : _info$name$split$.toLowerCase()))) {\n      return info.file;\n    }\n  }\n  return null;\n}\n\n// Transform JSON data to assessment format\nexport function transformJSONToAssessment(jsonData, studentId) {\n  if (!jsonData || !jsonData.words || !Array.isArray(jsonData.words)) {\n    return null;\n  }\n  const words = jsonData.words;\n  const passage = words.map(w => w.Word).join(' ');\n\n  // Count error types\n  let total_correct = 0;\n  let total_missed = 0;\n  let total_incorrect = 0;\n  let total_extras = 0;\n  words.forEach(word => {\n    var _word$error;\n    const errorType = (_word$error = word.error) === null || _word$error === void 0 ? void 0 : _word$error.toLowerCase();\n    if (errorType === 'right' || errorType === 'correct') {\n      total_correct++;\n    } else if (errorType === 'missed') {\n      total_missed++;\n    } else if (errorType === 'incorrect') {\n      total_incorrect++;\n    } else if (errorType === 'extra') {\n      total_extras++;\n    }\n  });\n\n  // Create assessment object\n  const studentInfo = STUDENT_JSON_MAP[studentId];\n  const studentKey = studentInfo ? studentInfo.name.toLowerCase().replace(/\\s+/g, '-') : 'student';\n  const assessment = {\n    id: `json-assessment-${studentKey}`,\n    student_id: studentId,\n    passage: passage,\n    cwpm_score: parseFloat(String(jsonData.cwpm)) || 0,\n    total_words: words.length,\n    total_correct: total_correct,\n    total_missed: total_missed,\n    total_incorrect: total_incorrect,\n    total_extras: total_extras,\n    assessment_date: new Date().toISOString().split('T')[0],\n    created_at: new Date().toISOString()\n  };\n\n  // Transform words to expected format\n  const transformedWords = words.map((word, index) => {\n    var _word$error2;\n    let wordType = (_word$error2 = word.error) === null || _word$error2 === void 0 ? void 0 : _word$error2.toLowerCase();\n    if (wordType === 'right') {\n      wordType = 'correct';\n    }\n    return {\n      id: 'json-word-' + index,\n      assessment_id: assessment.id,\n      word_text: word.Word || '',\n      student_answer: word.Align || null,\n      word_type: wordType || 'correct',\n      word_position: index + 1,\n      timestamp_start: parseFloat(String(word.start)) || 0,\n      timestamp_end: parseFloat(String(word.end)) || 0\n    };\n  });\n  return {\n    assessment: assessment,\n    words: transformedWords\n  };\n}\n// Supabase API functions\nexport const supabaseApi = {\n  // Get all students with latest CWPM\n  getStudents: async () => {\n    try {\n      const {\n        data,\n        error\n      } = await supabaseClient.from('student_performance').select('*').order('name');\n      if (error) throw error;\n      let students = data || [];\n\n      // Update students' latest CWPM from JSON if available\n      for (let i = 0; i < students.length; i++) {\n        const student = students[i];\n        const jsonFile = getStudentJSONFile(student.id, student.name);\n        if (jsonFile) {\n          const jsonData = await loadJSONData(jsonFile);\n          if (jsonData && jsonData.cwpm !== undefined) {\n            students[i].latest_cwpm = parseFloat(String(jsonData.cwpm));\n          }\n        }\n      }\n      return students;\n    } catch (error) {\n      console.error('Error fetching students:', error);\n      return [];\n    }\n  },\n  // Add new student\n  addStudent: async studentData => {\n    try {\n      const {\n        data: teachers\n      } = await supabaseClient.from('teachers').select('id').limit(1);\n      if (!teachers || teachers.length === 0) {\n        throw new Error('No teacher found');\n      }\n      const {\n        data,\n        error\n      } = await supabaseClient.from('students').insert([{\n        teacher_id: teachers[0].id,\n        name: studentData.name,\n        email: studentData.email,\n        password: studentData.password,\n        grade: studentData.grade,\n        course: studentData.course\n      }]).select().single();\n      if (error) throw error;\n      return data;\n    } catch (error) {\n      console.error('Error adding student:', error);\n      throw error;\n    }\n  },\n  // Get student with all assessments\n  getStudent: async studentId => {\n    try {\n      const {\n        data: student,\n        error: studentError\n      } = await supabaseClient.from('students').select('*').eq('id', studentId).single();\n      if (studentError) throw studentError;\n\n      // Check if this student has JSON data and load it\n      let jsonAssessment = null;\n      const jsonFile = getStudentJSONFile(studentId, student.name);\n      if (jsonFile) {\n        const jsonData = await loadJSONData(jsonFile);\n        if (jsonData) {\n          const transformed = transformJSONToAssessment(jsonData, studentId);\n          if (transformed) {\n            jsonAssessment = transformed.assessment;\n          }\n        }\n      }\n\n      // Get all assessments for this student\n      const {\n        data: assessments,\n        error: assessmentsError\n      } = await supabaseClient.from('assessments').select('*').eq('student_id', studentId).order('assessment_date');\n      if (assessmentsError) throw assessmentsError;\n\n      // Combine assessments: include JSON assessment for demo data\n      let allAssessments = assessments || [];\n      if (jsonAssessment) {\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1);\n        jsonAssessment.assessment_date = yesterday.toISOString().split('T')[0];\n        allAssessments.push(jsonAssessment);\n      }\n\n      // Sort all assessments by date\n      allAssessments.sort((a, b) => {\n        const dateA = new Date(a.assessment_date);\n        const dateB = new Date(b.assessment_date);\n        if (dateA.getTime() === dateB.getTime()) {\n          const createdA = a.created_at ? new Date(a.created_at) : new Date(0);\n          const createdB = b.created_at ? new Date(b.created_at) : new Date(0);\n          return createdA.getTime() - createdB.getTime();\n        }\n        return dateA.getTime() - dateB.getTime();\n      });\n      return {\n        student: student,\n        assessments: allAssessments\n      };\n    } catch (error) {\n      console.error('Error fetching student:', error);\n      throw error;\n    }\n  },\n  // Get student performance history\n  getPerformance: async studentId => {\n    try {\n      const {\n        data: student\n      } = await supabaseClient.from('students').select('name').eq('id', studentId).single();\n      const {\n        data,\n        error\n      } = await supabaseClient.from('assessments').select('assessment_date, cwpm_score, total_correct, total_missed, total_incorrect, total_extras').eq('student_id', studentId).order('assessment_date');\n      if (error) throw error;\n      let allData = data || [];\n      if (student) {\n        const jsonFile = getStudentJSONFile(studentId, student.name);\n        if (jsonFile) {\n          const jsonData = await loadJSONData(jsonFile);\n          if (jsonData) {\n            const transformed = transformJSONToAssessment(jsonData, studentId);\n            if (transformed && transformed.assessment) {\n              const jsonPerf = {\n                assessment_date: transformed.assessment.assessment_date,\n                cwpm_score: transformed.assessment.cwpm_score,\n                total_correct: transformed.assessment.total_correct,\n                total_missed: transformed.assessment.total_missed,\n                total_incorrect: transformed.assessment.total_incorrect,\n                total_extras: transformed.assessment.total_extras\n              };\n              allData.push(jsonPerf);\n              allData.sort((a, b) => {\n                const dateA = new Date(a.assessment_date);\n                const dateB = new Date(b.assessment_date);\n                return dateA.getTime() - dateB.getTime();\n              });\n            }\n          }\n        }\n      }\n      return allData.map(assessment => ({\n        date: new Date(assessment.assessment_date).toLocaleDateString('en-US', {\n          month: 'short',\n          day: 'numeric'\n        }),\n        cwpm_score: assessment.cwpm_score,\n        total_correct: assessment.total_correct,\n        total_missed: assessment.total_missed,\n        total_incorrect: assessment.total_incorrect,\n        total_extras: assessment.total_extras\n      }));\n    } catch (error) {\n      console.error('Error fetching performance:', error);\n      return [];\n    }\n  },\n  // Get specific assessment with word results\n  getAssessment: async assessmentId => {\n    try {\n      if (assessmentId && assessmentId.toString().startsWith('json-assessment-')) {\n        const studentKey = assessmentId.toString().replace('json-assessment-', '');\n        let studentId = null;\n        let jsonFile = null;\n        for (const [id, info] of Object.entries(STUDENT_JSON_MAP)) {\n          const keyFromName = info.name.toLowerCase().replace(/\\s+/g, '-');\n          if (keyFromName === studentKey) {\n            studentId = id;\n            jsonFile = info.file;\n            break;\n          }\n        }\n        if (studentId && jsonFile) {\n          const jsonData = await loadJSONData(jsonFile);\n          if (jsonData) {\n            const transformed = transformJSONToAssessment(jsonData, studentId);\n            if (transformed) {\n              return transformed;\n            }\n          }\n        }\n        throw new Error('JSON assessment not found');\n      }\n      const {\n        data: assessment,\n        error: assessmentError\n      } = await supabaseClient.from('assessments').select('*').eq('id', assessmentId).single();\n      if (assessmentError) throw assessmentError;\n      const {\n        data: words,\n        error: wordsError\n      } = await supabaseClient.from('word_results').select('*').eq('assessment_id', assessmentId).order('word_position');\n      if (wordsError) throw wordsError;\n      return {\n        assessment: assessment,\n        words: words || []\n      };\n    } catch (error) {\n      console.error('Error fetching assessment:', error);\n      throw error;\n    }\n  },\n  // Create new assessment\n  createAssessment: async assessmentData => {\n    try {\n      const {\n        student_id,\n        passage,\n        cwpm_score,\n        words,\n        assessment_date\n      } = assessmentData;\n      const total_words = passage.split(/\\s+/).length;\n      const total_correct = words ? words.filter(w => w.type === 'correct' || w.type === 'right').length : Math.floor(total_words * 0.7);\n      const total_missed = words ? words.filter(w => w.type === 'missed').length : Math.floor(total_words * 0.1);\n      const total_incorrect = words ? words.filter(w => w.type === 'incorrect').length : Math.floor(total_words * 0.1);\n      const total_extras = words ? words.filter(w => w.type === 'extra').length : Math.floor(total_words * 0.1);\n      const assessmentDate = assessment_date || new Date().toISOString().split('T')[0];\n      const {\n        data: assessment,\n        error: assessmentError\n      } = await supabaseClient.from('assessments').insert([{\n        student_id,\n        passage,\n        cwpm_score,\n        total_words,\n        total_correct,\n        total_missed,\n        total_incorrect,\n        total_extras,\n        assessment_date: assessmentDate\n      }]).select().single();\n      if (assessmentError) throw assessmentError;\n      if (words && words.length > 0) {\n        const wordRecords = words.map((word, index) => ({\n          assessment_id: assessment.id,\n          word_text: word.text || '',\n          student_answer: word.answer || null,\n          word_type: word.type || 'correct',\n          word_position: index + 1,\n          timestamp_start: word.start !== undefined ? word.start : index * 0.5,\n          timestamp_end: word.end !== undefined ? word.end : index * 0.5 + 0.3\n        }));\n        const {\n          error: wordsError\n        } = await supabaseClient.from('word_results').insert(wordRecords);\n        if (wordsError) throw wordsError;\n      }\n      return {\n        id: assessment.id,\n        message: 'Assessment created successfully'\n      };\n    } catch (error) {\n      console.error('Error creating assessment:', error);\n      throw error;\n    }\n  }\n};\n\n// Export students to CSV\nexport async function exportAllStudentsToCSV() {\n  try {\n    const students = await supabaseApi.getStudents();\n    let csv = 'Student Name,Email,Grade,Course,Latest CWPM\\n';\n    students.forEach(student => {\n      csv += `${student.name},${student.email},${student.grade},${student.course},${student.latest_cwpm || 0}\\n`;\n    });\n    downloadCSV(csv, 'all_students.csv');\n  } catch (error) {\n    console.error('Error exporting CSV:', error);\n    alert('Failed to export CSV');\n  }\n}\n\n// Helper to download CSV\nfunction downloadCSV(csvContent, filename) {\n  const blob = new Blob([csvContent], {\n    type: 'text/csv'\n  });\n  const url = window.URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = filename;\n  a.click();\n  window.URL.revokeObjectURL(url);\n}","map":{"version":3,"names":["supabaseClient","EMMA_JOHNSON_ID","EMMA_JOHNSON_NAME","LIAM_SMITH_ID","LIAM_SMITH_NAME","OLIVIA_DAVIS_ID","OLIVIA_DAVIS_NAME","STUDENT_JSON_MAP","name","file","jsonDataCache","loadJSONData","filename","response","fetch","Date","now","ok","console","warn","data","json","error","getStudentJSONFile","studentId","studentName","id","info","Object","entries","_info$name$split$","toLowerCase","includes","split","transformJSONToAssessment","jsonData","words","Array","isArray","passage","map","w","Word","join","total_correct","total_missed","total_incorrect","total_extras","forEach","word","_word$error","errorType","studentInfo","studentKey","replace","assessment","student_id","cwpm_score","parseFloat","String","cwpm","total_words","length","assessment_date","toISOString","created_at","transformedWords","index","_word$error2","wordType","assessment_id","word_text","student_answer","Align","word_type","word_position","timestamp_start","start","timestamp_end","end","supabaseApi","getStudents","from","select","order","students","i","student","jsonFile","undefined","latest_cwpm","addStudent","studentData","teachers","limit","Error","insert","teacher_id","email","password","grade","course","single","getStudent","studentError","eq","jsonAssessment","transformed","assessments","assessmentsError","allAssessments","yesterday","setDate","getDate","push","sort","a","b","dateA","dateB","getTime","createdA","createdB","getPerformance","allData","jsonPerf","date","toLocaleDateString","month","day","getAssessment","assessmentId","toString","startsWith","keyFromName","assessmentError","wordsError","createAssessment","assessmentData","filter","type","Math","floor","assessmentDate","wordRecords","text","answer","message","exportAllStudentsToCSV","csv","downloadCSV","alert","csvContent","blob","Blob","url","window","URL","createObjectURL","document","createElement","href","download","click","revokeObjectURL"],"sources":["/Users/ashwin/Desktop/GitHub/CFG-x-Wadhwani-AI/CFG-x-Wadhwani-AI/src/utils/supabaseApi.ts"],"sourcesContent":["// supabaseApi.ts - Supabase API utilities for React\nimport { supabaseClient } from '../config';\nimport type { JSONData, AssessmentDetails, Student, StudentData, PerformanceData, Assessment, WordResult, CreateAssessmentData } from '../types';\n\n// Student IDs and names (from data.sql)\nconst EMMA_JOHNSON_ID = '650e8400-e29b-41d4-a716-446655440001';\nconst EMMA_JOHNSON_NAME = 'Emma Johnson';\nconst LIAM_SMITH_ID = '650e8400-e29b-41d4-a716-446655440002';\nconst LIAM_SMITH_NAME = 'Liam Smith';\nconst OLIVIA_DAVIS_ID = '650e8400-e29b-41d4-a716-446655440003';\nconst OLIVIA_DAVIS_NAME = 'Olivia Davis';\n\ninterface StudentJSONMap {\n    [key: string]: { name: string; file: string };\n}\n\n// Mapping of students to their JSON files\nconst STUDENT_JSON_MAP: StudentJSONMap = {\n    [EMMA_JOHNSON_ID]: { name: EMMA_JOHNSON_NAME, file: 'test_input.json' },\n    [LIAM_SMITH_ID]: { name: LIAM_SMITH_NAME, file: 'test_input3.json' },\n    [OLIVIA_DAVIS_ID]: { name: OLIVIA_DAVIS_NAME, file: 'test_input2.json' }\n};\n\n// Cache for JSON data\nconst jsonDataCache: Record<string, JSONData> = {};\n\n// Load JSON data from specified file (always fresh, no caching)\nexport async function loadJSONData(filename: string): Promise<JSONData | null> {\n    try {\n        const response = await fetch(`/${filename}?t=${Date.now()}`);\n        if (!response.ok) {\n            console.warn(`Could not load ${filename}`);\n            return null;\n        }\n        const data = await response.json() as JSONData;\n        jsonDataCache[filename] = data;\n        return data;\n    } catch (error) {\n        console.error(`Error loading JSON data from ${filename}:`, error);\n        return null;\n    }\n}\n\n// Get JSON file for a student\nexport function getStudentJSONFile(studentId: string, studentName: string | null): string | null {\n    // Check by ID first\n    if (STUDENT_JSON_MAP[studentId]) {\n        return STUDENT_JSON_MAP[studentId].file;\n    }\n    \n    // Check by name\n    for (const [id, info] of Object.entries(STUDENT_JSON_MAP)) {\n        if (studentName && (studentName === info.name || \n            (typeof studentName === 'string' && \n             studentName.toLowerCase().includes(info.name.split(' ')[0].toLowerCase()) &&\n             studentName.toLowerCase().includes(info.name.split(' ')[1]?.toLowerCase())))) {\n            return info.file;\n        }\n    }\n    \n    return null;\n}\n\n// Transform JSON data to assessment format\nexport function transformJSONToAssessment(jsonData: JSONData, studentId: string): AssessmentDetails | null {\n    if (!jsonData || !jsonData.words || !Array.isArray(jsonData.words)) {\n        return null;\n    }\n\n    const words = jsonData.words;\n    const passage = words.map(w => w.Word).join(' ');\n    \n    // Count error types\n    let total_correct = 0;\n    let total_missed = 0;\n    let total_incorrect = 0;\n    let total_extras = 0;\n    \n    words.forEach(word => {\n        const errorType = word.error?.toLowerCase();\n        if (errorType === 'right' || errorType === 'correct') {\n            total_correct++;\n        } else if (errorType === 'missed') {\n            total_missed++;\n        } else if (errorType === 'incorrect') {\n            total_incorrect++;\n        } else if (errorType === 'extra') {\n            total_extras++;\n        }\n    });\n\n    // Create assessment object\n    const studentInfo = STUDENT_JSON_MAP[studentId];\n    const studentKey = studentInfo ? studentInfo.name.toLowerCase().replace(/\\s+/g, '-') : 'student';\n    const assessment: Assessment = {\n        id: `json-assessment-${studentKey}`,\n        student_id: studentId,\n        passage: passage,\n        cwpm_score: parseFloat(String(jsonData.cwpm)) || 0,\n        total_words: words.length,\n        total_correct: total_correct,\n        total_missed: total_missed,\n        total_incorrect: total_incorrect,\n        total_extras: total_extras,\n        assessment_date: new Date().toISOString().split('T')[0],\n        created_at: new Date().toISOString()\n    };\n\n    // Transform words to expected format\n    const transformedWords: WordResult[] = words.map((word, index) => {\n        let wordType = word.error?.toLowerCase();\n        if (wordType === 'right') {\n            wordType = 'correct';\n        }\n        \n        return {\n            id: 'json-word-' + index,\n            assessment_id: assessment.id,\n            word_text: word.Word || '',\n            student_answer: word.Align || null,\n            word_type: (wordType || 'correct') as WordResult['word_type'],\n            word_position: index + 1,\n            timestamp_start: parseFloat(String(word.start)) || 0,\n            timestamp_end: parseFloat(String(word.end)) || 0\n        };\n    });\n\n    return {\n        assessment: assessment,\n        words: transformedWords\n    };\n}\n\ninterface StudentFormData {\n    name: string;\n    email: string;\n    password: string;\n    grade: string;\n    course: string;\n}\n\n// Supabase API functions\nexport const supabaseApi = {\n    // Get all students with latest CWPM\n    getStudents: async (): Promise<Student[]> => {\n        try {\n            const { data, error } = await supabaseClient\n                .from('student_performance')\n                .select('*')\n                .order('name');\n            \n            if (error) throw error;\n            \n            let students: Student[] = (data || []) as Student[];\n            \n            // Update students' latest CWPM from JSON if available\n            for (let i = 0; i < students.length; i++) {\n                const student = students[i];\n                const jsonFile = getStudentJSONFile(student.id, student.name);\n                \n                if (jsonFile) {\n                    const jsonData = await loadJSONData(jsonFile);\n                    if (jsonData && jsonData.cwpm !== undefined) {\n                        students[i].latest_cwpm = parseFloat(String(jsonData.cwpm));\n                    }\n                }\n            }\n            \n            return students;\n        } catch (error) {\n            console.error('Error fetching students:', error);\n            return [];\n        }\n    },\n    \n    // Add new student\n    addStudent: async (studentData: StudentFormData): Promise<Student> => {\n        try {\n            const { data: teachers } = await supabaseClient\n                .from('teachers')\n                .select('id')\n                .limit(1);\n            \n            if (!teachers || teachers.length === 0) {\n                throw new Error('No teacher found');\n            }\n            \n            const { data, error } = await supabaseClient\n                .from('students')\n                .insert([{\n                    teacher_id: teachers[0].id,\n                    name: studentData.name,\n                    email: studentData.email,\n                    password: studentData.password,\n                    grade: studentData.grade,\n                    course: studentData.course\n                }])\n                .select()\n                .single();\n            \n            if (error) throw error;\n            return data as Student;\n        } catch (error) {\n            console.error('Error adding student:', error);\n            throw error;\n        }\n    },\n    \n    // Get student with all assessments\n    getStudent: async (studentId: string): Promise<StudentData> => {\n        try {\n            const { data: student, error: studentError } = await supabaseClient\n                .from('students')\n                .select('*')\n                .eq('id', studentId)\n                .single();\n            \n            if (studentError) throw studentError;\n            \n            // Check if this student has JSON data and load it\n            let jsonAssessment: Assessment | null = null;\n            const jsonFile = getStudentJSONFile(studentId, student.name);\n            if (jsonFile) {\n                const jsonData = await loadJSONData(jsonFile);\n                if (jsonData) {\n                    const transformed = transformJSONToAssessment(jsonData, studentId);\n                    if (transformed) {\n                        jsonAssessment = transformed.assessment;\n                    }\n                }\n            }\n            \n            // Get all assessments for this student\n            const { data: assessments, error: assessmentsError } = await supabaseClient\n                .from('assessments')\n                .select('*')\n                .eq('student_id', studentId)\n                .order('assessment_date');\n            \n            if (assessmentsError) throw assessmentsError;\n            \n            // Combine assessments: include JSON assessment for demo data\n            let allAssessments: Assessment[] = (assessments || []) as Assessment[];\n            if (jsonAssessment) {\n                const yesterday = new Date();\n                yesterday.setDate(yesterday.getDate() - 1);\n                jsonAssessment.assessment_date = yesterday.toISOString().split('T')[0];\n                allAssessments.push(jsonAssessment);\n            }\n            \n            // Sort all assessments by date\n            allAssessments.sort((a, b) => {\n                const dateA = new Date(a.assessment_date);\n                const dateB = new Date(b.assessment_date);\n                if (dateA.getTime() === dateB.getTime()) {\n                    const createdA = a.created_at ? new Date(a.created_at) : new Date(0);\n                    const createdB = b.created_at ? new Date(b.created_at) : new Date(0);\n                    return createdA.getTime() - createdB.getTime();\n                }\n                return dateA.getTime() - dateB.getTime();\n            });\n            \n            return {\n                student: student as Student,\n                assessments: allAssessments\n            };\n        } catch (error) {\n            console.error('Error fetching student:', error);\n            throw error;\n        }\n    },\n    \n    // Get student performance history\n    getPerformance: async (studentId: string): Promise<PerformanceData[]> => {\n        try {\n            const { data: student } = await supabaseClient\n                .from('students')\n                .select('name')\n                .eq('id', studentId)\n                .single();\n            \n            const { data, error } = await supabaseClient\n                .from('assessments')\n                .select('assessment_date, cwpm_score, total_correct, total_missed, total_incorrect, total_extras')\n                .eq('student_id', studentId)\n                .order('assessment_date');\n            \n            if (error) throw error;\n            \n            let allData: any[] = data || [];\n            if (student) {\n                const jsonFile = getStudentJSONFile(studentId, student.name);\n                if (jsonFile) {\n                    const jsonData = await loadJSONData(jsonFile);\n                    if (jsonData) {\n                        const transformed = transformJSONToAssessment(jsonData, studentId);\n                        if (transformed && transformed.assessment) {\n                            const jsonPerf = {\n                                assessment_date: transformed.assessment.assessment_date,\n                                cwpm_score: transformed.assessment.cwpm_score,\n                                total_correct: transformed.assessment.total_correct,\n                                total_missed: transformed.assessment.total_missed,\n                                total_incorrect: transformed.assessment.total_incorrect,\n                                total_extras: transformed.assessment.total_extras\n                            };\n                            allData.push(jsonPerf);\n                            allData.sort((a, b) => {\n                                const dateA = new Date(a.assessment_date);\n                                const dateB = new Date(b.assessment_date);\n                                return dateA.getTime() - dateB.getTime();\n                            });\n                        }\n                    }\n                }\n            }\n            \n            return allData.map(assessment => ({\n                date: new Date(assessment.assessment_date).toLocaleDateString('en-US', { \n                    month: 'short', \n                    day: 'numeric' \n                }),\n                cwpm_score: assessment.cwpm_score,\n                total_correct: assessment.total_correct,\n                total_missed: assessment.total_missed,\n                total_incorrect: assessment.total_incorrect,\n                total_extras: assessment.total_extras\n            })) as PerformanceData[];\n        } catch (error) {\n            console.error('Error fetching performance:', error);\n            return [];\n        }\n    },\n    \n    // Get specific assessment with word results\n    getAssessment: async (assessmentId: string): Promise<AssessmentDetails> => {\n        try {\n            if (assessmentId && assessmentId.toString().startsWith('json-assessment-')) {\n                const studentKey = assessmentId.toString().replace('json-assessment-', '');\n                \n                let studentId: string | null = null;\n                let jsonFile: string | null = null;\n                \n                for (const [id, info] of Object.entries(STUDENT_JSON_MAP)) {\n                    const keyFromName = info.name.toLowerCase().replace(/\\s+/g, '-');\n                    if (keyFromName === studentKey) {\n                        studentId = id;\n                        jsonFile = info.file;\n                        break;\n                    }\n                }\n                \n                if (studentId && jsonFile) {\n                    const jsonData = await loadJSONData(jsonFile);\n                    if (jsonData) {\n                        const transformed = transformJSONToAssessment(jsonData, studentId);\n                        if (transformed) {\n                            return transformed;\n                        }\n                    }\n                }\n                \n                throw new Error('JSON assessment not found');\n            }\n            \n            const { data: assessment, error: assessmentError } = await supabaseClient\n                .from('assessments')\n                .select('*')\n                .eq('id', assessmentId)\n                .single();\n            \n            if (assessmentError) throw assessmentError;\n            \n            const { data: words, error: wordsError } = await supabaseClient\n                .from('word_results')\n                .select('*')\n                .eq('assessment_id', assessmentId)\n                .order('word_position');\n            \n            if (wordsError) throw wordsError;\n            \n            return {\n                assessment: assessment as Assessment,\n                words: (words || []) as WordResult[]\n            };\n        } catch (error) {\n            console.error('Error fetching assessment:', error);\n            throw error;\n        }\n    },\n    \n    // Create new assessment\n    createAssessment: async (assessmentData: CreateAssessmentData): Promise<{ id: string; message: string }> => {\n        try {\n            const { student_id, passage, cwpm_score, words, assessment_date } = assessmentData;\n            \n            const total_words = passage.split(/\\s+/).length;\n            const total_correct = words ? words.filter(w => w.type === 'correct' || w.type === 'right').length : Math.floor(total_words * 0.7);\n            const total_missed = words ? words.filter(w => w.type === 'missed').length : Math.floor(total_words * 0.1);\n            const total_incorrect = words ? words.filter(w => w.type === 'incorrect').length : Math.floor(total_words * 0.1);\n            const total_extras = words ? words.filter(w => w.type === 'extra').length : Math.floor(total_words * 0.1);\n            \n            const assessmentDate = assessment_date || new Date().toISOString().split('T')[0];\n            \n            const { data: assessment, error: assessmentError } = await supabaseClient\n                .from('assessments')\n                .insert([{\n                    student_id,\n                    passage,\n                    cwpm_score,\n                    total_words,\n                    total_correct,\n                    total_missed,\n                    total_incorrect,\n                    total_extras,\n                    assessment_date: assessmentDate\n                }])\n                .select()\n                .single();\n            \n            if (assessmentError) throw assessmentError;\n            \n            if (words && words.length > 0) {\n                const wordRecords = words.map((word, index) => ({\n                    assessment_id: assessment.id,\n                    word_text: word.text || '',\n                    student_answer: word.answer || null,\n                    word_type: word.type || 'correct',\n                    word_position: index + 1,\n                    timestamp_start: word.start !== undefined ? word.start : index * 0.5,\n                    timestamp_end: word.end !== undefined ? word.end : (index * 0.5 + 0.3)\n                }));\n                \n                const { error: wordsError } = await supabaseClient\n                    .from('word_results')\n                    .insert(wordRecords);\n                \n                if (wordsError) throw wordsError;\n            }\n            \n            return { id: assessment.id, message: 'Assessment created successfully' };\n        } catch (error) {\n            console.error('Error creating assessment:', error);\n            throw error;\n        }\n    }\n};\n\n// Export students to CSV\nexport async function exportAllStudentsToCSV(): Promise<void> {\n    try {\n        const students = await supabaseApi.getStudents();\n        \n        let csv = 'Student Name,Email,Grade,Course,Latest CWPM\\n';\n        \n        students.forEach(student => {\n            csv += `${student.name},${student.email},${student.grade},${student.course},${student.latest_cwpm || 0}\\n`;\n        });\n        \n        downloadCSV(csv, 'all_students.csv');\n    } catch (error) {\n        console.error('Error exporting CSV:', error);\n        alert('Failed to export CSV');\n    }\n}\n\n// Helper to download CSV\nfunction downloadCSV(csvContent: string, filename: string): void {\n    const blob = new Blob([csvContent], { type: 'text/csv' });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    a.click();\n    window.URL.revokeObjectURL(url);\n}\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}